\input{labspre.tex}

\usepackage[compact]{titlesec}

\usepackage[url=false,
    backend=biber,
    style=authoryear,
    doi=false,
    isbn=false,
    backref=false,
    dashed=false,                                   % Do not add a dash out authors for subsequent articles with the same authors.
    maxnames=99,                                    % Amount of authors to include before abbreviating.
    sorting=ydnt]{biblatex}                         % Sorting in reverse order
\renewbibmacro{in:}{}

\addbibresource{bibliography_schemaanalyst.bib}

\begin{document}
\MYTITLE{Final Project Assignment: Implementing a Complete Programming Systems Product}
\MYHEADERS{Final Project Assignment}{Due: December 11, 2015 by 5 pm}

\vspace*{-.1in}
\section*{Introduction}

\nocite{*}

Throughout the semester, you have learned about the phases of the software development lifecycle and both the software
tools and the non-cognitive skills that are needed to support the creation of high-quality software in each of these
phases. Yet, none of the past laboratory assignments required you to deliver a programming systems product to an
external customer. In this laboratory assignment, you will gain experience in working with and understanding a large,
real-world software system created by external customers who want to release it to GitHub under a free and open-source
license.  Additionally, you will use tools, like JDepend and JavaNCSS, to characterize this large, already implemented
system. You and your team members will also explore both the issues related to effective technology transfer and the
ways to improve the quality of a software system's documentation. Finally, you will learn more about the licensing of
free and open-source software.

\vspace*{-.05in}
\section*{Learning About SchemaAnalyst}



\vspace*{-.05in}
\section*{Accessing and Using SchemaAnalyst}



Of course, it is also important to characterize the quality of a test suite that SchemaAnalyst automatically generates.
One way to evaluate tests is to use mutation analysis; please refer to the papers in the ``References'' section to learn
more about how mutation analysis can help you to understand the quality of a test suite. Can you and your team members
run the mutation analysis feature provided by SchemaAnalyst? What are the inputs and outputs of SchemaAnalyst when it
performs a mutation analysis of a test suite? Overall, how good are the generated test suites?

\vspace*{-.05in}
\section*{Preparing SchemaAnalyst for Public Release}

You and your team members should review the existing documentation provided by the customers and develop some ideas for
ways in which you can improve it further. For instance, the current documentation does not show the output (i.e., the
test suite) that SchemaAnalyst produces when you ask it to generate tests. In addition, there is no detailed description
of the purpose and behavior of SchemaAnalyst. Of course, the {\tt README.md} that will display on the front page of your
Git site would also benefit from a terminal recording, created with a tool like {\tt asciinema}, that demonstrates the
system's key features (to learn more about this tool, you can visit \url{https://asciinema.org/}). Finally, since
SchemaAnalyst contains a commercial library called ``General SQL Parser'' you will need to interact with the external
customers to determine the best way to publish their tool under an appropriate open-source license. To ensure that your
team is chosen for the privilege of releasing SchemaAnalyst to GitHub, you may also consider other ways in
which you can prepare the customers' tool for release. Please see the instructor if you have questions about \mbox{these
tasks}.

\section*{Evaluating SchemaAnalyst's Design and Implementation}

In addition to releasing the SchemaAnalyst system, it is important for your team to evaluate the quality of its design.
First, your team should use a tool called JDepend; as in a previous assignment, you can learn more about JDepend by
visiting \url{http://clarkware.com/software/JDepend.html}.  Before you start the next phase of this assignment please
make sure that all of your team members fully understand all of the details about the design quality metrics that
JDepend calculates.  Your team can use these metrics to better understand the quality of SchemaAnalyst's design and
make suggestions, to the external customers, for ways in which the design of SchemaAnalyst could be improved. As one of
the deliverables for this assignment, your team should use Markdown to prepare a document that contains formal
definitions and equations that describe all of the design quality metrics and then comments on the relevant
characteristics of SchemaAnalyst's design.

It is also essential for your team to calculate metrics that characterize the quality of SchemaAnalyst's implementation.
As you know from a previous laboratory assignment, JavaNCSS is a software tool that can automatically scan your Java
source code and report information about the number of non-commented source code statements and the cyclomatic
complexity.  If you have not already done so, you can learn more about JavaNCSS by visiting
\url{http://www.kclee.de/clemens/java/javancss/}. After reading the Web site for JavaNCSS, each member of your team
should search for papers in the ACM Digital Library, available at \url{http://dl.acm.org/}, that formally describe the
meaning of the metrics calculated by JavaNCSS, such as cyclomatic complexity. As one of the deliverables for this
assignment, your team should use Markdown to write formal definitions and equations that fully explain all of the
metrics calculated by JavaNCSS.

Once all of the members of your team understand the metrics calculated by JavaNCSS, you should download and install this
tool.  As you did with JDepend, now you must learn how to run JavaNCSS and then apply it to the source code of the
system implemented by your external customers.  What does the output of JavaNCSS tell you about the quality of
SchemaAnalyst's implementation? Does SchemaAnalyst exhibit good implementation characteristics? How can you use the
values of these metrics to better understand and suggest modifications for the implementation of the SchemaAnalyst
system? How much of SchemaAnalyst's source code is for the program itself? How much of the source code is devoted to the
test suite?  Overall, how well is SchemaAnalyst documented? What are ways in which your team can improve SchemaAnalyst's
documentation?

Additionally, your external customers want you to consider assessing the quality of the test suite that they have
implemented for SchemaAnalyst. For instance, your team can think about using a test coverage analysis tool like JaCoCo
to calculate the code coverage of SchemaAnalyst's test suite. Alternatively, you could use a tool like MAJOR to perform
a mutation analysis of SchemaAnalyst's tests; students who want to learn more about MAJOR and the concepts underlying
mutation analysis are encouraged to read several of the papers in the ``References'' section and to visit MAJOR's Web
site, available at \url{http://mutation-testing.org/}. At minimum, your team must document the baseline characteristics
of the test suite. For instance, how many tests come with SchemaAnalyst? Do all of the test cases pass?  Are there tests
for all of SchemaAnalyst's packages?

Along with running software tools, like JDepend and JavaNCSS, to automatically assess the quality of SchemaAnalyst's
design and implementation, you should also take time, as a team, to conceptualize and visualize the design of your
customers' tool. Following the outline of the unified modelling (UML) diagram in Figure 6.22 of SETP, your team should
create a high-level package diagram for SchemaAnalyst. Next, your team should pick at least one major ``sub-system'' in
SchemaAnalyst and create a UML class diagram, like Figures 6.18, 6.20, and 6.21, that shows the relationship among the
classes in this sub-system. Please use a technical drawing tool to crease these UML diagrams; students should consider
using a tool like Mermaid, available at \url{https://github.com/knsv/mermaid/}, to program these diagrams and make them
available in their repository. Finally, your team should prepare an explanation of at least one example of how
SchemaAnalyst employs object-oriented principles (i.e., polymorphism, inheritance, \mbox{and encapsulation)}.

\section*{Review the Textbooks for Key Ideas}

To best ensure your team's success at completing this project, you should review all of the content in Chapters 1--6 of
SETP, focusing on Chapter 3's relevant details about the process of developing software. Every member of the team should
also review Chapters 1--4 of MMM, reconsidering topics such as the roles in a software development team and the
techniques that help developers achieve conceptual integrity in a design. Refreshing your understanding of this content
will best ensure that your team works well together when completing this assignment --- and help you to prepare for the
final project where you will deliver another large-scale system to an external customer.

Although not absolutely required for the successful completion of this laboratory assignment, you may also wish to
review SETP's material about software documentation (see Section 10.2) and technology transfer (see Section 14.2).
Additionally, you may examine Chapter 15 of MMM to learn more about ways in which you can document software. Although
this optional content in SETP and MMM reinforces concepts already introduced in past class and laboratory sessions, it
may provide further context to support your release a programming systems product on behalf of the external customers.
Please see the instructor if you have questions about any of these \mbox{reading assignments}.

\section*{Summary of the Required Deliverables}

This assignment invites your team to submit one printed version of the following files:

\vspace*{-.1in}
\begin{enumerate}
  \itemsep0em
  \item A description of and justification for your team's chosen organization, roles, and tool support
  \item A complete {\tt README.md} file that fully explains how to use your software tool
  \item A document that clearly explains the meaning of JDepend's design quality metrics
  \item A document that clearly explains the meaning of the metrics calculated by JavaNCSS
  \item A full-featured written analysis of the values of all the relevant metrics for your tool
  \item A written analysis of the quality of the test suite that your team implemented
  \item Technical diagrams that correctly visualize the architecture and design of your tool
  \item A written explanation of how your tool employs the principles of object-oriented design
  \item A complete demonstration of your programming systems product to your customer
  \item A detailed one or two paragraph review of your demonstration written by your customer
\end{enumerate}
\vspace*{-.1in}

% \newpage

\defbibfilter{papers}{
  type=article or
  type=inproceedings or
  type=incollection and
  not keyword=edit
}
\DeclareFieldFormat[article]{volume}{\addcomma\addspace#1\nopunct}
\DeclareFieldFormat[article]{number}{(#1)}
\DeclareFieldFormat[inproceedings]{booktitle}{in \em{#1}}
\DeclareFieldFormat[article]{title}{\mkbibquote{#1\addcomma}}
\DeclareFieldFormat[inproceedings]{title}{\mkbibquote{#1\addcomma}}
\DeclareFieldFormat[incollection]{title}{\mkbibquote{#1\addcomma}}
\printbibliography[filter=papers,title={References}]

\end{document}

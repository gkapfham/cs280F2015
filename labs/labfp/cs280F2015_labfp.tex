\input{labspre.tex}

\usepackage[compact]{titlesec}

\usepackage[url=false,
    backend=biber,
    style=authoryear,
    doi=false,
    isbn=false,
    backref=false,
    dashed=false,                                   % Do not add a dash out authors for subsequent articles with the same authors.
    maxnames=99,                                    % Amount of authors to include before abbreviating.
    sorting=ydnt]{biblatex}                         % Sorting in reverse order
\renewbibmacro{in:}{}

\addbibresource{bibliography_schemaanalyst.bib}

\begin{document}
\MYTITLE{Final Project Assignment: Implementing a Complete Programming Systems Product}
\MYHEADERS{Final Project Assignment}{Due: December 11, 2015 by 5 pm}

\vspace*{-.1in}
\section*{Introduction}

\nocite{*}

Throughout the semester, you have learned about the phases of the software development lifecycle and both the software
tools and the non-cognitive skills that are needed to support the creation of high-quality software in each of these
phases. Yet, with the exception of the previous laboratory assignment, none of the past work required you to deliver a
programming systems product to an external customer. Moreover, even in this past assignment you did not proceed through
the entire software development lifecycle to specify, architect, design, implement, test, document, and release a
complete programming systems product that fully meets the needs of your external customer.

In this final project assignment, you will gain experience in eliciting requirements from an external customer. Then,
using these requirements, you will architect and design a system that will meet the needs of your customer. While always
keeping in direct contact with your client through discussions in the course's Slack team, in-person meetings, and short
demonstrations, your team will then implement and test your software. Next, your team will produce comprehensive
documentation that will ensure that your customer can easily use your program after this course has completed.
Ultimately, your team must create a GitHub project for your system and, with the approval of the customer, release the
system under a free and open-source license.

Additionally, your team will use tools, like JDepend, JavaNCSS, JaCoCo, and MAJOR, to characterize and evaluate the
software system that you implement and release.  As you complete this assignment, you and your team members should
always remember that, while your customer is an expert in the domain in which you must implement software, this
individual is not a computer scientist or a software engineer who has studied the material in Computer Science 280.
Therefore, you should present to your customer an intuitive explanation of what the results from the analysis tools say
about the quality of the final system that you are delivering.  Finally, as in the previous assignment, you and your
team members will also explore both the issues related to effective technology transfer, the ways to improve the quality
of a software system's documentation, and the best practices in the licensing and release of free and open-source
software.

\section*{Eliciting Requirements from the Customer}

For this laboratory assignment, your team is tasked with specifying, designing, implementing, documenting, and releasing
a programming systems product that will give users insights into all of the Git projects in their filesystem. For the
same of simplicity, this assignment sheet will refer to this product as {\tt git-beagle} because it will ``retrieve''
the important details about all of the Git repositories that are stored in a user's directories; each team is encouraged
to develop their own name for their programming systems product that best represents their tool's key features.

You should interact with the course instructor to learn more about the features that {\tt git-beagle} should provide.
Additionally, one of your team members should investigate existing tools or online discussion forums that outline the
features that are common to software tools like {\tt git-beagle}. However, the basic function of the tool will proceed
in the following manner. When given a root file system directory, {\tt git-beagle} will recursively traverse the
filesystem and look for all of the directories that contain local or remote Git repositories. After finding a Git
repository, {\tt git-beagle} will collect and report relevant information about this repository. For instance, your tool
might report files that have been modified but not yet committed and files that are currently in the directory but
not tracked by Git. If {\tt git-beagle} finds a Git repository that is ``clean'' and thus has nothing to commit, it
should also report this information to the user. The {\tt git-beagle} program should also report summary statistics that
note details about, for instance, how many repositories were found overall and how many files were in the repositories
but not yet added to Git's records.

For this laboratory assignment, all of the students responsible for requirements elicitation and analysis will interact
with the customer at the same time. In addition, these students may assume, for this assignment, that the customer is a
computer scientist who understands many of the intricacies associated with using the Git version control. When a team
learns something important about the features of the system, then one of this team's members should share these details
with all of the other team members through an appropriate channel in Slack. Since the ultimate goal for our course is to
release a final version of {\tt git-beagle} in a subsequent assignment, teams can share details about the system's
requirements within the appropriate bounds of the Honor Code.

\section*{Designing the System}

For this assignment, teams are encouraged to design and implement a system that uses whatever programming languages,
development environments, and execution means that are most suited to the knowledge and skills of the team's members.
In light of this freedom, the language used in this section and the following sections will be ``generic'' and thus not,
for instance, refer to language concepts (e.g., ``object-oriented'' or ``Java class'') that are specific to a single
programming language or development environment. Please see the course instructor if you have questions about this
issue.

Working with the members of your team and leveraging the content in the requirements document, you should create a
design for your system.  As you are finalizing the system's design, you should try to develop answers to relevant
questions such as: How many components will you use? What will be the relationship between the components? What
functions will the components have? What will be the inputs and outputs of the functions?  Is the design easy to
understand?  Can you actually implement and test this design? After answering these questions, you should use Markdown
to write a design document with text and diagrams that explain the system. Since the main focus of this assignment is
not design diagrams, students may use any reasonable tool to create their diagrams and, if necessary, include them as
separate files in their team's repository. When clarification of the system's specification is necessary (e.g., due to
writing ambiguities), the designers should interact with the individual(s) who elicited \mbox{the requirements}. Yet,
your team should carefully ensure that the system's requirements and design are correctly in sync.

\section*{Implementing and Testing the System}

The developer(s) and tester(s) on your team should take the requirements and design documents and start to think about
how the system will be implemented. Your task is to ensure that the program faithfully adheres to the descriptions
already produced by other members of your team. When an aspect of the requirements and design documents is not clear,
the developer(s) must talk with the people who created these documents to resolve any outstanding concerns. The creators
of these documents must quickly commit any changes in them to their repository so as to best ensure that the
requirements and design of the system are in sync with its implementation.

As this programming systems product will be released to GitHub in a subsequent assignment, the implementors and testers
should take care to create a system that is well-documented through comments and other relevant documentation. Whenever
it is possible to do so, these members of your team must also add (semi-)automated methods for verifying that the
implementation adheres to the requirements that previously were elicited from the customer. For instance, if your team
decides to implement {\tt git-beagle} in the Java programming language, then you should test it with automated tests
cases that you wrote in JUnit, the industry standard for automated testing in Java. Overall, as you are implementing and
testing your system you should hold yourselves to a high standard under the assumption that other software engineers
will review and use your code.

Of course, it is also important to characterize the quality of a test suite that SchemaAnalyst automatically generates.
One way to evaluate tests is to use mutation analysis; please refer to the papers in the ``References'' section to learn
more about how mutation analysis can help you to understand the quality of a test suite. Can you and your team members
run the mutation analysis feature provided by SchemaAnalyst? What are the inputs and outputs of SchemaAnalyst when it
performs a mutation analysis of a test suite? Overall, how good are the generated test suites?

\vspace*{-.05in}
\section*{Preparing Your System for Public Release}

You and your team members should review the existing documentation provided by the customers and develop some ideas for
ways in which you can improve it further. For instance, the current documentation does not show the output (i.e., the
test suite) that SchemaAnalyst produces when you ask it to generate tests. In addition, there is no detailed description
of the purpose and behavior of SchemaAnalyst. Of course, the {\tt README.md} that will display on the front page of your
Git site would also benefit from a terminal recording, created with a tool like {\tt asciinema}, that demonstrates the
system's key features (to learn more about this tool, you can visit \url{https://asciinema.org/}). Finally, since
SchemaAnalyst contains a commercial library called ``General SQL Parser'' you will need to interact with the external
customers to determine the best way to publish their tool under an appropriate open-source license. To ensure that your
team is chosen for the privilege of releasing SchemaAnalyst to GitHub, you may also consider other ways in
which you can prepare the customers' tool for release. Please see the instructor if you have questions about \mbox{these
tasks}.

\section*{Evaluating SchemaAnalyst's Design and Implementation}

In addition to releasing the SchemaAnalyst system, it is important for your team to evaluate the quality of its design.
First, your team should use a tool called JDepend; as in a previous assignment, you can learn more about JDepend by
visiting \url{http://clarkware.com/software/JDepend.html}.  Before you start the next phase of this assignment please
make sure that all of your team members fully understand all of the details about the design quality metrics that
JDepend calculates.  Your team can use these metrics to better understand the quality of SchemaAnalyst's design and
make suggestions, to the external customers, for ways in which the design of SchemaAnalyst could be improved. As one of
the deliverables for this assignment, your team should use Markdown to prepare a document that contains formal
definitions and equations that describe all of the design quality metrics and then comments on the relevant
characteristics of SchemaAnalyst's design.

It is also essential for your team to calculate metrics that characterize the quality of SchemaAnalyst's implementation.
As you know from a previous laboratory assignment, JavaNCSS is a software tool that can automatically scan your Java
source code and report information about the number of non-commented source code statements and the cyclomatic
complexity.  If you have not already done so, you can learn more about JavaNCSS by visiting
\url{http://www.kclee.de/clemens/java/javancss/}. After reading the Web site for JavaNCSS, each member of your team
should search for papers in the ACM Digital Library, available at \url{http://dl.acm.org/}, that formally describe the
meaning of the metrics calculated by JavaNCSS, such as cyclomatic complexity. As one of the deliverables for this
assignment, your team should use Markdown to write formal definitions and equations that fully explain all of the
metrics calculated by JavaNCSS.

Once all of the members of your team understand the metrics calculated by JavaNCSS, you should download and install this
tool.  As you did with JDepend, now you must learn how to run JavaNCSS and then apply it to the source code of the
system implemented by your external customers.  What does the output of JavaNCSS tell you about the quality of
SchemaAnalyst's implementation? Does SchemaAnalyst exhibit good implementation characteristics? How can you use the
values of these metrics to better understand and suggest modifications for the implementation of the SchemaAnalyst
system? How much of SchemaAnalyst's source code is for the program itself? How much of the source code is devoted to the
test suite?  Overall, how well is SchemaAnalyst documented? What are ways in which your team can improve SchemaAnalyst's
documentation?

Additionally, your external customers want you to consider assessing the quality of the test suite that they have
implemented for SchemaAnalyst. For instance, your team can think about using a test coverage analysis tool like JaCoCo
to calculate the code coverage of SchemaAnalyst's test suite. Alternatively, you could use a tool like MAJOR to perform
a mutation analysis of SchemaAnalyst's tests; students who want to learn more about MAJOR and the concepts underlying
mutation analysis are encouraged to read several of the papers in the ``References'' section and to visit MAJOR's Web
site, available at \url{http://mutation-testing.org/}. At minimum, your team must document the baseline characteristics
of the test suite. For instance, how many tests come with SchemaAnalyst? Do all of the test cases pass?  Are there tests
for all of SchemaAnalyst's packages?

Along with running software tools, like JDepend and JavaNCSS, to automatically assess the quality of SchemaAnalyst's
design and implementation, you should also take time, as a team, to conceptualize and visualize the design of your
customers' tool. Following the outline of the unified modelling (UML) diagram in Figure 6.22 of SETP, your team should
create a high-level package diagram for SchemaAnalyst. Next, your team should pick at least one major ``sub-system'' in
SchemaAnalyst and create a UML class diagram, like Figures 6.18, 6.20, and 6.21, that shows the relationship among the
classes in this sub-system. Please use a technical drawing tool to crease these UML diagrams; students should consider
using a tool like Mermaid, available at \url{https://github.com/knsv/mermaid/}, to program these diagrams and make them
available in their repository. Finally, your team should prepare an explanation of at least one example of how
SchemaAnalyst employs object-oriented principles (i.e., polymorphism, inheritance, \mbox{and encapsulation)}.

\section*{Review the Textbooks for Key Ideas}

To best ensure your team's success at completing this project, you should review all of the content in Chapters 1--6 of
SETP, focusing on Chapter 3's relevant details about the process of developing software. Every member of the team should
also review Chapters 1--4 of MMM, reconsidering topics such as the roles in a software development team and the
techniques that help developers achieve conceptual integrity in a design. Refreshing your understanding of this content
will best ensure that your team works well together when completing this assignment --- and help you to prepare for the
final project where you will deliver another large-scale system to an external customer.

Although not absolutely required for the successful completion of this laboratory assignment, you may also wish to
review SETP's material about software documentation (see Section 10.2) and technology transfer (see Section 14.2).
Additionally, you may examine Chapter 15 of MMM to learn more about ways in which you can document software. Although
this optional content in SETP and MMM reinforces concepts already introduced in past class and laboratory sessions, it
may provide further context to support your release a programming systems product on behalf of the external customers.
Please see the instructor if you have questions about any of these \mbox{reading assignments}.

\section*{Summary of the Required Deliverables}

This assignment invites your team to submit one printed version of the following files:

\vspace*{-.1in}
\begin{enumerate}
  \itemsep0em
  \item A description of and justification for your team's chosen organization, roles, and tool support
  \item A complete {\tt README.md} file that fully explains how to use your programming systems product
  \item A document that intuitively explains the meaning of the relevant design-quality metrics
  \item A document that intuitively explains the meaning of the relevant code-quality metrics
  \item A full-featured written analysis of the values of all the relevant metrics for your tool
  \item Technical diagrams that correctly visualize the architecture and design of your system
  \item A written explanation of how your tool employs the principles of object-oriented design
  \item A complete demonstration of your programming systems product to your customer
  \item A detailed one or two paragraph review of your demonstration written by your customer
  \item A separately submitted written evaluation of the work that you and your team completed
\end{enumerate}
\vspace*{-.1in}

\end{document}
